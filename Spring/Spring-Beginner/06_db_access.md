# 스프링 DB 접근 기술
> 본 게시물은 김영한님의 [스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/dashboard) 강의를 듣고 정리한 내용입니다.  
게시물에 포함된 코드와 이미지 등의 모든 저작권은 인프런과 김영한 강사님께 있습니다.

**Object**
1. [H2 데이터 베이스 설치](#h2-데이터-베이스-설치)
2. [순수 Jdbc](#순수-jdbc)
3. [스프링 통합 테스트](#스프링-통합-테스트)
4. [스프링 JdbcTemplate](#스프링-jdbctemplate)
5. [JPA](#jpa)
6. [스프링 데이터 JPA](#스프링-데이터-jpa)

- 애플리케이션 서버와 DB를 연결할 때 **Jdbc** 기술이 필요하다.
- 순수 Jdbc로 개발하기 너무 어렵다고 한다 ㅜㅜ (옛날이야기)
- 스프링이 **JdbcTemplate** 기술을 제공한다.
  - 애플리케이션에서 데이터베이스로 SQL을 편하게 날릴 수 있다.
- 이에 모자라서, SQL조차 직접 짜지 않고 **JPA**라는 기술이 DB 등록, 수정, 삭제 등의 쿼리를 다 날려준다!
  - JPA를 사용하면, 객체를 쿼리 없이 바로 DB에 저장할 수 있다.

## H2 데이터 베이스 설치
- 개발이나 테스트 용도로 많이 쓰인다.
  `h2.bat`: 실행
  `jdbc:h2:tcp://localhost/~/test`

### 테이블 생성하기
- 테이블 관리를 위해 프로젝트 루트에 `sql/ddl.sql` 파일을 생성한다.
```sql
drop table if exists member CASCADE; -- 드랍 스크립트, 지워도 무방
create table member
(
    id  bigint generated by default as identity, /* 값을 세팅하지 않고 insert하면
                                                    DB가 들어왔을 때 자동으로 id 값을 채워줌    */
    name varchar(255),
    primary key (id)
);
```
- H2 데이터베이스에 접근해서 `member` 테이블을 생성한다.

> 데이터베이스가 정상 생성되지 않을 때 -> 강의 노트 참고하기

### Insert
```sql
insert into member(name) values('spring')
```   
![Image](https://github.com/user-attachments/assets/17b36aa0-53bd-42e6-ac4f-4d55ae4b55b3)

## 순수 Jdbc
- 20년 전 방식 ㅋㅋ
### 환경 설정
**bulid.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가**
```
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```
- 자바는 DB랑 붙으려면 Jdbc 드라이버가 있어야 한다.

**스프링 부트 데이터베이스 연결 설정 추가**
```
// resources/application.properties
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```
- 공백 주의 (아예 없어야 한다.)

### Jdbc 리포지토리 구현
- 20년 전 방식이니 가볍게 보자
**Jdbc 회원 리포지토리**
```java
코드 생략
```

- `DataSource`는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 `DataSource`를 생성하고 스프링 빈으로 만들어둔다. 그래서 DI를 받을 수 있다.

![Image](https://github.com/user-attachments/assets/add2d860-a066-4f2e-9bcc-85b2832e0c23)
- `MemberService`는 `MemberRepository`를 의존한다.
- `MemberRepository`는 구현체로 `MemoryMemberRepository`와 `JdbcMemberRepository`가 있다.

![Image](https://github.com/user-attachments/assets/042637af-d243-4e72-8886-219ebba655f6)
- 기존에는 `memory` 버전의 MemberRepository를 스프링 빈으로 등록했는데, 이를 빼고 `Jdbc` 버전의 memberRepository를 등록한다.
- 개방-폐쇄 원칙(OCP, Open-Closed Principle)
  - 확장에는 열려 있고, 수정에는 닫혀있다.
- 스프링의 DI을 사용하면 **기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경**할 수 있다.

## 스프링 통합 테스트
스프링 컨테이너와 DB까지 연결한 통합 테스트를 해보자~

**회원 서비스 스프링 통합 테스트**
```java
코드 생략
```
- **`@SpringBootTest`**
  - 스프링 컨테이너와 테스트를 함께 실행한다.
- **`@Transactional`**
  - 테스트 시작 전에 트랜잭션을 시작하고, 테스트가 끝나면 롤백한다.
  - 즉, DB에 데이터가 반영이 안된다. (테스트 반복 실행 가능!)
  - `@Commit`을 사용하면 반영된다.
- 통합 테스트 보다는 순수한 단위 테스트가 좋은 테스트!

## 스프링 JdbcTemplate
- 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다. 하지만 SQL은 직접 작성해야 한다.

**스프링 JdbcTemplate 회원 리포지토리**
```java
// repository/JdbcTemplateMemberRepository
public class JdbcTemplateMemberRepository implements MemberRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());

        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
        return result.stream().findAny();
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    private RowMapper<Member> memberRowMapper() {
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }
}
```
- 순수 Jdbc에서 엄청 길었던 코드들이 간단해졌다~

**JdbcTemplate을 사용하도록 스프링 설정 변경**
```java
@Configuration
public class SpringConfig {

    @Bean
    public MemberRepository memberRepository() {
        // return new MemoryMemberRepository();
        // return new JdbcMemberRepository(dataSource);
        return new JdbcTemplateMemberRepository(dataSource);
    }
}
```
- 테스트 코드 잘 짜는 게 매우매우 중요!!

## JPA
- JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해준다.
- JPA를 사용하면, SQL과 데이터 중심의 설계에서 **객체 중심의 설계**로 패러다임을 전환 할 수 있다.
- JPA를 사용하면 개발 생산성을 크게 높일 수 있다.
- JPA -> 인터페이스
- **ORM(Object Relational Mapping)**: 객체의 오브젝트와 관계형 데이터베이스의 테이블을 맵핑한다.

**build.gradle 파일에 JPA, h2 데이터베이스 관련 라이브러리 추가**
```
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
```

**스프링 부트에 JPA 설정 추가**
```
// resources/application.properties
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```
- `show-sql`: JAP가 생성하는 SQL을 출력한다.
- `ddl-auto`: JPA는 테이블을 자동으로 생성하는 기능을 제공하는데, `none`을 사용하면 해당 기능을 끈다.
  - `create`를 사용하면 엔티티 정보를 바탕으로 테이블을 직접 생성해준다. -> 해보장~

**JPA 엔티티 매핑**
```java
// domain/Member
@Entity
public class Member {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
}
```
- `IDENTITY`: DB가 자동으로 생성해주는 거 (ex. h2의 ID) 

**JPA 회원 리포지토리**
```java
public class JpaMemberRepository implements MemberRepository {

    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }
}
```
- JPA를 사용하기 위해서는 `EntityManager`를 주입 받아야 한다.
- `ctrl + alt + n`: inline

**서비스 계층에 트랜잭션 추가**
```java
@Transactional
public class MemberService { }
```
- 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작하고, 메서드가 정상 종료되면 트랜잭션을 커밋한다.
  - 만약 런타임 예외가 발생하면 롤백한다.
- **JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다.**

**JPA를 사용하도록 스프링 설정 변경**
```java
@Configuration
public class SpringConfig {

    private EntityManager em;

    @Autowired
    public SpringConfig(EntityManager em) {
        this.em = em;
    }

    @Bean
    public MemberRepository memberRepository() {
        // return new MemoryMemberRepository();
        // return new JdbcMemberRepository(dataSource);
        //return new JdbcTemplateMemberRepository(dataSource);
        return new JpaMemberRepository(em);
    }
}
```

## 스프링 데이터 JPA
- 스프링 부트와 JPA만 사용해도 개발 생산성이 많이 증가하고, 개발 해야 할 코드도 확연히 줄어든다!
- 여기에 **스프링 데이터 JPA**도 사용하면, 기존의 한계를 넘어서 리포지토리에 구현 클래스 없이 인터페이스 만으로 개발 할 수 있다. (헐)
  - 반복 개발해온 기본 CRUD 기능도 제공한다.
- 단순하고 반복이라고 생각했던 개발 코드들이 확연히 줄어들어 개발이 정말 즐거워진다. (진짜루?)
  - 핵심 비즈니스 로직을 개발하는 데 집중할 수 있다.
> 스프링 데이터 JPA는 JPA를 편리하게 사용하도록 도와주는 기술이기 때문에 **우선 JPA 먼저 익히도록 하자**

**스프링 데이터 JPA 회원 리포지토리**
```java
public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository {

    @Override
    Optional<Member> findByName(String name);
}
```
- 인터페이스는 다중 상속이 가능하다. (기억 안나면 자바를 복습하자)
- `SpringDataJpaMemberRepository`가 `JpaRepository`를 받고 있으면 구현체를 자동으로 만들어준다.
  - 스프링 빈을 자동으로 등록! -> 우린 이걸 가져다쓰면 되지롱

**스프링 데이터 JPA 회원 리포지토리를 사용하도록 스프링 설정 변경**
```java
@Configuration
public class SpringConfig {

    private final MemberRepository memberRepository;

    @Autowired // 생략 가능
    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository);
    }
}
```

**스프링 데이터 JPA 제공 클래스**
![Image](https://github.com/user-attachments/assets/715d15f5-5538-4ed4-b3a9-258ddfe6a580)   

**스프링 데이터 JPA 제공 기능**
- 인터페이스를 통한 기본적인 CRUD
- `findByName()` , `findByEmail()` 처럼 메서드 이름 만으로 조회 기능을 제공한다.
- 페이징 기능 자동으로 제공한다.

> 복잡한 동적 쿼리는 **Querydsl**이라는 라이브러리를 사용하면 된다.
> Querydsl을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다.
> 이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나, 앞서 학습한 스프링 JdbcTemplate를 사용하면 된다.